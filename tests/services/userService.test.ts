// tests/services/userService.test.ts
import { db, initializeSchema } from '../../src/database'; 
import * as userService from '../../src/services/userService';
import { User } from '../../src/models/user.types';
import { v4 as uuidv4 } from 'uuid';

// Hold the original db path and switch to in-memory for tests
let originalDbPath: string | undefined;

// This will be the actual test database instance
let testDb: import('better-sqlite3').Database;

beforeAll(() => {
  // Assume the `db` instance from `src/database/index.ts` is already
  // configured to be in-memory for the 'test' NODE_ENV.
  // Forcing schema re-initialization on the imported `db`.
  
  // Clean slate: Drop tables if they exist from a previous run
  try {
    db.exec("DROP TABLE IF EXISTS api_keys;");
    db.exec("DROP TABLE IF EXISTS users;");
    db.exec("DROP TABLE IF EXISTS financial_data;"); 
  } catch (error) {
    // console.warn("Failed to drop tables, they might not exist yet.", error);
  }
  initializeSchema(); 
});

beforeEach(async () => {
  // Clean the users table before each test
  try {
    db.exec('DELETE FROM users;');
  } catch (error) {
    console.error("Error cleaning users table", error);
    // If table doesn't exist, schema might not have been init'd correctly
    initializeSchema(); 
    db.exec('DELETE FROM users;');
  }
});

afterAll(() => {
  // db.close(); // Close the in-memory database
});

describe('User Service (Database Interactions)', () => {
  describe('createUser', () => {
    it('should correctly insert a user into the database and return the user object', () => {
      const userData = {
        email: 'test@example.com',
        passwordHash: 'hashedpassword123',
      };
      const createdUser = userService.createUser(userData);

      expect(createdUser).toBeDefined();
      expect(createdUser.id).toEqual(expect.any(String)); // ID is generated by uuid
      expect(createdUser.email).toBe(userData.email);
      expect(createdUser.passwordHash).toBe(userData.passwordHash);
      expect(createdUser.createdAt).toEqual(expect.any(Number));
      expect(createdUser.updatedAt).toEqual(expect.any(Number));
      // Check if updatedAt is greater than or equal to createdAt, and the difference is small
      expect(createdUser.updatedAt).toBeGreaterThanOrEqual(createdUser.createdAt);
      expect(createdUser.updatedAt - createdUser.createdAt).toBeLessThan(100); // e.g., less than 100ms difference

      // Verify from DB
      const dbUser = db.prepare('SELECT * FROM users WHERE id = ?').get(createdUser.id) as User;
      expect(dbUser).toBeDefined();
      expect(dbUser.email).toBe(userData.email);
      expect(dbUser.id).toBe(createdUser.id);
      expect(dbUser.createdAt).toBe(createdUser.createdAt);
    });

    it('should throw an error or handle duplicate email registration if UNIQUE constraint works', () => {
      const userData = { email: 'duplicate@example.com', passwordHash: 'pass1' };
      userService.createUser(userData); // First creation
      try {
        userService.createUser(userData); // Try creating again with same email
        fail('Should have thrown an error for duplicate email'); // This line will cause test to fail if no error is thrown
      } catch (error: any) {
        expect(error).toBeDefined();
        // Check for SQLite constraint error
        // Error: UNIQUE constraint failed: users.email
        expect(error.message).toMatch(/UNIQUE constraint failed: users.email/i);
      }
    });
  });

  describe('findUserByEmail', () => {
    it('should find an existing user by email', () => {
      const userData = { email: 'findme@example.com', passwordHash: 'passfind' };
      const createdUser = userService.createUser(userData);

      const foundUser = userService.findUserByEmail(userData.email);
      expect(foundUser).toBeDefined();
      expect(foundUser!.id).toBe(createdUser.id);
      expect(foundUser!.email).toBe(userData.email);
    });

    it('should return undefined for a non-existent email', () => {
      const foundUser = userService.findUserByEmail('nonexistent@example.com');
      expect(foundUser).toBeUndefined();
    });
  });

  describe('findUserById', () => {
    it('should find an existing user by ID', () => {
      const userData = { email: 'findbyid@example.com', passwordHash: 'passid' };
      const createdUser = userService.createUser(userData);

      const foundUser = userService.findUserById(createdUser.id);
      expect(foundUser).toBeDefined();
      expect(foundUser!.id).toBe(createdUser.id);
      expect(foundUser!.email).toBe(userData.email);
    });

    it('should return undefined for a non-existent ID', () => {
      const foundUser = userService.findUserById(uuidv4()); // Random non-existent ID
      expect(foundUser).toBeUndefined();
    });
  });

  describe('getAllUsers', () => {
    it('should return all users', () => {
      const user1Data = { email: 'user1@all.com', passwordHash: 'pass1all' };
      const user2Data = { email: 'user2@all.com', passwordHash: 'pass2all' };
      userService.createUser(user1Data);
      userService.createUser(user2Data);

      const allUsers = userService.getAllUsers();
      expect(allUsers).toBeDefined();
      expect(allUsers.length).toBe(2);
      expect(allUsers.find(u => u.email === user1Data.email)).toBeDefined();
      expect(allUsers.find(u => u.email === user2Data.email)).toBeDefined();
    });

    it('should return an empty array if no users exist', () => {
      const allUsers = userService.getAllUsers();
      expect(allUsers).toBeDefined();
      expect(allUsers.length).toBe(0);
    });
  });
});
